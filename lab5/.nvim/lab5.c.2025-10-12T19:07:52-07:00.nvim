#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <limits.h>   // For UINT64_MAX

// Structure representing a memory block
struct header {
    uint64_t size;              // size of the free block
    struct header *next;        // pointer to next block
    int id;                     // identifier for the block
};

// Initialize a block
void initialize_block(struct header *block, uint64_t size, struct header *next, int id) {
    block->size = size;
    block->next = next;
    block->id = id;
}

// -----------------------------------------------------------
// First-Fit: return the ID of the first block large enough
// -----------------------------------------------------------
int find_first_fit(struct header *free_list_ptr, uint64_t size) {
    struct header *current = free_list_ptr;
    while (current != NULL) {
        if (current->size >= size) {
            return current->id;
        }
        current = current->next;
    }
    return -1; // No suitable block found
}

// -----------------------------------------------------------
// Best-Fit: return ID of the smallest block that fits
// -----------------------------------------------------------
int find_best_fit(struct header *free_list_ptr, uint64_t size) {
    int best_fit_id = -1;
    uint64_t best_fit_size = UINT64_MAX;
    struct header *current = free_list_ptr;

    while (current != NULL) {
        if (current->size >= size && current->size < best_fit_size) {
            best_fit_size = current->size;
            best_fit_id = current->id;
        }
        current = current->next;
    }
    return best_fit_id;
}

// -----------------------------------------------------------
// Worst-Fit: return ID of the largest block that fits
// -----------------------------------------------------------
int find_worst_fit(struct header *free_list_ptr, uint64_t size) {
    int worst_fit_id = -1;
    uint64_t worst_fit_size = 0;
    struct header *current = free_list_ptr;

    while (current != NULL) {
        if (current->size >= size && current->size > worst_fit_size) {
            worst_fit_size = current->size;
            worst_fit_id = current->id;
        }
        current = current->next;
    }
    return worst_fit_id;
}

// -----------------------------------------------------------
// Main function to test
// -----------------------------------------------------------
int main(void) {
    struct header *free_block1 = (struct header*) malloc(sizeof(struct header));
    struct header *free_block2 = (struct header*) malloc(sizeof(struct header));
    struct header *free_block3 = (struct header*) malloc(sizeof(struct header));
    struct header *free_block4 = (struct header*) malloc(sizeof(struct header));
    struct header *free_block5 = (struct header*) malloc(sizeof(struct header));

    initialize_block(free_block1, 6,  free_block2, 1);
    initialize_block(free_block2, 12, free_block3, 2);
    initialize_block(free_block3, 24, free_block4, 3);
    initialize_block(free_block4, 8,  free_block5, 4);
    initialize_block(free_block5, 4,  NULL,       5);

    struct header *free_list_ptr = free_block1;

    int first_fit_id = find_first_fit(free_list_ptr, 7);
    int best_fit_id  = find_best_fit(free_list_ptr, 7);
    int worst_fit_id = find_worst_fit(free_list_ptr, 7);

    printf("The ID for First-Fit algorithm is: %d\n", first_fit_id);
    printf("The ID for Best-Fit algorithm is: %d\n", best_fit_id);
    printf("The ID for Worst-Fit algorithm is: %d\n", worst_fit_id);

    // Free allocated memory
    free(free_block1);
    free(free_block2);
    free(free_block3);
    free(free_block4);
    free(free_block5);

    return 0;
}

/*
------------------------------------------------------------
Part 2: Coalescing Contiguous Free Blocks (Pseudo-code)
------------------------------------------------------------

Goal:
When a block of memory is freed, we want to merge adjacent
free blocks into one larger block to reduce fragmentation.

------------------------------------------------------------
Algorithm: coalesce(free_list_ptr)
------------------------------------------------------------

Input:
  free_list_ptr — pointer to the first free block in the list
  (List must be sorted by memory address)

Steps:

1. current = free_list_ptr

2. while (current != NULL and current->next != NULL):
      a. end_addr = address(current) + current->size
      b. next_addr = address(current->next)

      c. if end_addr == next_addr:
            // Merge current and next
            current->size = current->size + current->next->size
            current->next = current->next->next
         else:
            current = current->next

3. return free_list_ptr

------------------------------------------------------------
Example:

Before:
[Block1 size=6] → [Block2 size=12] → [Block3 size=24]
Assume Block1 and Block2 are contiguous.

After:
[Block1+2 size=18] → [Block3 size=24]

------------------------------------------------------------
End of Part 2
*/

